!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Begin_Timestamp	GPIO_Interrupt.py	/^Begin_Timestamp = 0$/;"	v
ClearQueue	GPIO_Interrupt.c	/^int ClearQueue(LinkQueue *Q) \/\/ 清空队列$/;"	f
DeQueue	GPIO_Interrupt.c	/^int DeQueue(LinkQueue *Q,QElemType *e) \/\/ 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR$/;"	f
DestroyQueue	GPIO_Interrupt.c	/^int DestroyQueue(LinkQueue *Q) \/\/ 销毁队列$/;"	f
ERROR	GPIO_Interrupt.h	26;"	d
EnQueue	GPIO_Interrupt.c	/^int EnQueue(LinkQueue *Q,QElemType e)  \/\/ 插入元素e为Q的新的队尾元素$/;"	f
End_Timestamp	GPIO_Interrupt.py	/^End_Timestamp = 0$/;"	v
GetHead	GPIO_Interrupt.c	/^int GetHead(LinkQueue Q,QElemType *e)  \/\/ 获得队头元素，若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR $/;"	f
Get_Timestamp	GPIO_Interrupt.c	/^timestamp Get_Timestamp()$/;"	f
HighLevelCounter	GPIO_Interrupt.py	/^HighLevelCounter = 0$/;"	v
InitQueue	GPIO_Interrupt.c	/^int InitQueue(LinkQueue *Q)    \/\/ 构造一个空队列$/;"	f
InterruptCounter	GPIO_Interrupt.py	/^InterruptCounter = 0$/;"	v
LED	GPIO_Interrupt.c	/^void LED(void)$/;"	f
LED	GPIO_Interrupt.py	/^def LED(self):$/;"	f
LinkQueue	GPIO_Interrupt.h	/^}LinkQueue;$/;"	t	typeref:struct:__anon1
LowLevelCounter	GPIO_Interrupt.py	/^LowLevelCounter = 0$/;"	v
MAXSIZE	GPIO_Interrupt.h	27;"	d
OK	GPIO_Interrupt.h	25;"	d
PinFalling_input	GPIO_Interrupt.h	19;"	d
PinFalling_input	GPIO_Interrupt.py	/^PinFalling_input = 38$/;"	v
PinRising_input	GPIO_Interrupt.h	18;"	d
PinRising_input	GPIO_Interrupt.py	/^PinRising_input = 37$/;"	v
Pin_output	GPIO_Interrupt.h	21;"	d
Pin_output	GPIO_Interrupt.py	/^Pin_output = 22$/;"	v
QElemType	GPIO_Interrupt.h	/^typedef timestamp QElemType;$/;"	t
QNode	GPIO_Interrupt.h	/^typedef struct QNode    \/\/ 节点结构$/;"	s
QNode	GPIO_Interrupt.h	/^}QNode, *QueuePtr;$/;"	t	typeref:struct:QNode
QueueEmpty	GPIO_Interrupt.c	/^int QueueEmpty(LinkQueue Q)$/;"	f
QueueLength	GPIO_Interrupt.c	/^int QueueLength(LinkQueue Q) \/\/ 求队列的长度$/;"	f
QueuePtr	GPIO_Interrupt.h	/^}QNode, *QueuePtr;$/;"	t	typeref:struct:QNode
QueueTraverse	GPIO_Interrupt.c	/^int QueueTraverse(LinkQueue Q)   \/\/ 从队头到队尾依次对队列Q中每个元素输出$/;"	f
Setup	GPIO_Interrupt.c	/^void Setup(void)$/;"	f
SwitchCounter	GPIO_Interrupt.py	/^SwitchCounter = 0$/;"	v
Time_Stamp	GPIO_Interrupt.h	/^typedef struct Time_Stamp$/;"	s
_TIMESTAMP_H	GPIO_Interrupt.h	9;"	d
data	GPIO_Interrupt.h	/^    QElemType data;$/;"	m	struct:QNode
front	GPIO_Interrupt.h	/^    QueuePtr front, rear;$/;"	m	struct:__anon1
lt	GPIO_Interrupt.h	/^    struct tm * lt;$/;"	m	struct:Time_Stamp	typeref:struct:Time_Stamp::tm
main	GPIO_Interrupt.c	/^int main (void)$/;"	f
next	GPIO_Interrupt.h	/^    struct QNode *next;$/;"	m	struct:QNode	typeref:struct:QNode::QNode
rear	GPIO_Interrupt.h	/^    QueuePtr front, rear;$/;"	m	struct:__anon1
switch_count	GPIO_Interrupt.c	/^static volatile int switch_count = 0;$/;"	v	file:
timestamp	GPIO_Interrupt.h	/^}timestamp;$/;"	t	typeref:struct:Time_Stamp
tv	GPIO_Interrupt.h	/^    struct timeval tv;$/;"	m	struct:Time_Stamp	typeref:struct:Time_Stamp::timeval
visit	GPIO_Interrupt.c	/^int visit(QElemType c)$/;"	f
